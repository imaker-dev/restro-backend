const { Server } = require('socket.io');
const { createAdapter } = require('@socket.io/redis-adapter');
const Redis = require('ioredis');
const corsConfig = require('./cors.config');
const redisConfig = require('./redis.config');
const logger = require('../utils/logger');
const { pubsub, isRedisAvailable, publishMessage, registerLocalEmitter } = require('./redis');

let io = null;

const initializeSocket = (server) => {
  // Build Socket.IO CORS: allow mobile apps (no Origin header) + web origins
  const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',').map(s => s.trim()).filter(Boolean) || [];
  const socketCors = {
    ...corsConfig,
    origin: (origin, callback) => {
      // Allow requests with no origin (mobile apps, server-to-server, curl)
      if (!origin) return callback(null, true);
      // In development, allow all
      if (process.env.NODE_ENV !== 'production') return callback(null, true);
      // Always allow localhost origins for development/testing
      if (origin.includes('localhost') || origin.includes('127.0.0.1')) return callback(null, true);
      // In production, check against allowed origins
      if (allowedOrigins.length === 0 || allowedOrigins.includes(origin)) {
        return callback(null, true);
      }
      logger.warn(`Socket.IO CORS rejected origin: ${origin}`);
      return callback(new Error('Not allowed by CORS'));
    },
  };

  io = new Server(server, {
    cors: socketCors,
    pingInterval: parseInt(process.env.WS_PING_INTERVAL, 10) || 25000,
    pingTimeout: parseInt(process.env.WS_PING_TIMEOUT, 10) || 60000,
    transports: ['polling', 'websocket'],
    allowEIO3: true,
    path: process.env.SOCKET_PATH || '/socket.io',
    // Mobile app compatibility settings
    cookie: false, // Disable cookies - mobile apps use query params for session tracking
    allowUpgrades: true, // Allow upgrades from polling to websocket
    httpCompression: false, // Disable compression for better mobile compatibility
    addTrailingSlash: false, // Some mobile HTTP clients don't handle trailing slashes well
    perMessageDeflate: false, // Disable compression for WebSocket (can cause issues with some clients)
    // Additional mobile-friendly settings
    connectTimeout: 45000, // Connection timeout for mobile clients
    maxHttpBufferSize: 1e6, // 1MB max buffer size
  });

  // Log Socket.IO initialization
  const port = server.address()?.port || process.env.PORT || process.env.PROD_PORT || 'unknown';
  logger.info(`Socket.IO server initialized on port ${port} at path ${process.env.SOCKET_PATH || '/socket.io/'}`);
  logger.info(`Socket.IO transports: ${['websocket', 'polling'].join(', ')}`);

  // Attach Redis adapter for PM2 cluster mode session sharing
  if (isRedisAvailable()) {
    try {
      const pubClient = new Redis({
        host: redisConfig.host,
        port: redisConfig.port,
        password: redisConfig.password,
        db: redisConfig.db,
      });
      const subClient = pubClient.duplicate();
      io.adapter(createAdapter(pubClient, subClient));
      logger.info('Socket.IO Redis adapter attached (cluster-safe)');
    } catch (err) {
      logger.warn('Socket.IO Redis adapter setup failed, cluster sync disabled:', err.message);
    }
  }

  // Log all incoming requests to Socket.IO
  io.engine.on('initial_headers', (headers, req) => {
    logger.debug(`[Socket.IO] Incoming request: ${req.method} ${req.url}`);
    logger.debug(`[Socket.IO] Headers: ${JSON.stringify(req.headers)}`);
  });

  // Log connection errors at engine level (before 'connection' event)
  io.engine.on('connection_error', (err) => {
    logger.error(`[Socket.IO Engine] connection_error: code=${err.code} message=${err.message} context=${JSON.stringify(err.context || {})}`);
    if (err.req) {
      logger.error(`[Socket.IO Engine] Request URL: ${err.req.url}`);
      logger.error(`[Socket.IO Engine] Request method: ${err.req.method}`);
      logger.error(`[Socket.IO Engine] Request headers: ${JSON.stringify(err.req.headers || {})}`);
    }
  });

  // Log handshake attempts
  io.use((socket, next) => {
    logger.info(`[Socket.IO] Handshake attempt from ${socket.handshake.address}`);
    logger.info(`[Socket.IO] Query params: ${JSON.stringify(socket.handshake.query)}`);
    logger.info(`[Socket.IO] Headers: ${JSON.stringify(socket.handshake.headers)}`);
    logger.info(`[Socket.IO] Auth: ${JSON.stringify(socket.handshake.auth)}`);
    next();
  });

  // Connection handler
  io.on('connection', (socket) => {
    logger.info(`Socket connected: ${socket.id} transport=${socket.conn.transport.name}`);

    // Join outlet room
    socket.on('join:outlet', (outletId) => {
      socket.join(`outlet:${outletId}`);
      logger.debug(`Socket ${socket.id} joined outlet:${outletId}`);
    });

    // Join floor room
    socket.on('join:floor', ({ outletId, floorId }) => {
      socket.join(`floor:${outletId}:${floorId}`);
      logger.debug(`Socket ${socket.id} joined floor:${outletId}:${floorId}`);
    });

    // Join kitchen room
    socket.on('join:kitchen', (outletId) => {
      socket.join(`kitchen:${outletId}`);
      logger.debug(`Socket ${socket.id} joined kitchen:${outletId}`);
    });

    // Join bar room
    socket.on('join:bar', (outletId) => {
      socket.join(`bar:${outletId}`);
      logger.debug(`Socket ${socket.id} joined bar:${outletId}`);
    });

    // Join station room by station_type (main_kitchen, tandoor, wok, dessert, bar, mocktail, etc.)
    // Also supports joining by station_id for precise routing
    socket.on('join:station', ({ outletId, station, stationId }) => {
      // If station is numeric, treat it as station_id
      if (station && !isNaN(station) && Number.isInteger(Number(station))) {
        const numericStationId = parseInt(station);
        socket.join(`station_id:${outletId}:${numericStationId}`);
        logger.info(`Socket ${socket.id} joined station_id:${outletId}:${numericStationId} (auto-detected from station param)`);
      } else if (station) {
        // Join by station_type (e.g., main_kitchen, dessert, bar)
        socket.join(`station:${outletId}:${station}`);
        logger.info(`Socket ${socket.id} joined station:${outletId}:${station}`);
      }
      
      // Also join by explicit stationId param for precise routing
      if (stationId) {
        socket.join(`station_id:${outletId}:${stationId}`);
        logger.info(`Socket ${socket.id} joined station_id:${outletId}:${stationId}`);
      }
    });

    // Join cashier room
    socket.on('join:cashier', (outletId) => {
      socket.join(`cashier:${outletId}`);
      logger.debug(`Socket ${socket.id} joined cashier:${outletId}`);
    });

    // Join captain room (for order updates)
    socket.on('join:captain', (outletId) => {
      socket.join(`captain:${outletId}`);
      logger.debug(`Socket ${socket.id} joined captain:${outletId}`);
    });

    // Leave rooms
    socket.on('leave:outlet', (outletId) => {
      socket.leave(`outlet:${outletId}`);
    });

    socket.on('leave:floor', ({ outletId, floorId }) => {
      socket.leave(`floor:${outletId}:${floorId}`);
    });

    socket.on('leave:kitchen', (outletId) => {
      socket.leave(`kitchen:${outletId}`);
    });

    // Disconnect handler
    socket.on('disconnect', (reason) => {
      logger.info(`Socket disconnected: ${socket.id}, reason: ${reason}`);
    });

    // Error handler
    socket.on('error', (error) => {
      logger.error(`Socket error: ${socket.id}`, error);
    });
  });

  // Subscribe to Redis channels for cross-worker communication (if Redis available)
  if (isRedisAvailable()) {
    setupRedisPubSub();
  } else {
    logger.warn('Socket.IO running without Redis pub/sub - multi-instance sync disabled');
  }

  // Register local emitter as fallback when Redis is unavailable
  registerLocalEmitter(emitLocal);
  logger.info('Local socket emitter registered as fallback');

  return io;
};

const setupRedisPubSub = () => {
  if (!isRedisAvailable()) return;
  // Table updates
  pubsub.subscribe('table:update', (data) => {
    io.to(`floor:${data.outletId}:${data.floorId}`).emit('table:updated', data);
    io.to(`outlet:${data.outletId}`).emit('table:updated', data);
  });

  // Order updates - broadcast to outlet, captain, and cashier
  pubsub.subscribe('order:update', (data) => {
    io.to(`outlet:${data.outletId}`).emit('order:updated', data);
    io.to(`captain:${data.outletId}`).emit('order:updated', data);
    io.to(`cashier:${data.outletId}`).emit('order:updated', data);
  });

  // KOT updates - route to specific station, kitchen, captain, and cashier
  pubsub.subscribe('kot:update', (data) => {
    const kotNum = data.kot?.kotNumber || data.kot?.id || 'unknown';
    logger.info(`[RedisPubSub] kot:update received - outlet: ${data.outletId}, station: ${data.station}, stationId: ${data.stationId}, type: ${data.type}, kotNumber: ${kotNum}`);
    
    // Track rooms we're emitting to
    const emittedRooms = [];
    
    // Send to general kitchen room (backward compatibility)
    io.to(`kitchen:${data.outletId}`).emit('kot:updated', data);
    emittedRooms.push(`kitchen:${data.outletId}`);
    
    // Send to specific station room by station_type (main_kitchen, dessert, bar, etc.)
    if (data.station) {
      io.to(`station:${data.outletId}:${data.station}`).emit('kot:updated', data);
      emittedRooms.push(`station:${data.outletId}:${data.station}`);
      
      // Also send to bar room if bar station type (backward compatibility)
      if (data.station === 'bar' || data.station.includes('bar')) {
        io.to(`bar:${data.outletId}`).emit('kot:updated', data);
        emittedRooms.push(`bar:${data.outletId}`);
      }
    }
    
    // Send to specific station by station_id for precise routing
    if (data.stationId) {
      io.to(`station_id:${data.outletId}:${data.stationId}`).emit('kot:updated', data);
      emittedRooms.push(`station_id:${data.outletId}:${data.stationId}`);
    }
    
    // Send ALL KOT status updates to captain and cashier for real-time tracking
    io.to(`captain:${data.outletId}`).emit('kot:updated', data);
    io.to(`cashier:${data.outletId}`).emit('kot:updated', data);
    emittedRooms.push(`captain:${data.outletId}`, `cashier:${data.outletId}`);

    // Keep backward-compatible item:ready event for captain
    if (data.type === 'kot:item_ready' || data.type === 'kot:ready') {
      io.to(`captain:${data.outletId}`).emit('item:ready', data);
    }
    
    logger.info(`[RedisPubSub] KOT ${kotNum} emitted to rooms: ${emittedRooms.join(', ')}`);
  });

  // Bill status updates - send to captain and cashier
  pubsub.subscribe('bill:status', (data) => {
    io.to(`captain:${data.outletId}`).emit('bill:status', data);
    io.to(`cashier:${data.outletId}`).emit('bill:status', data);
    io.to(`outlet:${data.outletId}`).emit('bill:status', data);
  });

  // Payment updates - send to cashier and outlet
  pubsub.subscribe('payment:update', (data) => {
    io.to(`cashier:${data.outletId}`).emit('payment:updated', data);
    io.to(`outlet:${data.outletId}`).emit('payment:updated', data);
  });

  // Notification
  pubsub.subscribe('notification', (data) => {
    io.to(`outlet:${data.outletId}`).emit('notification', data);
  });
};

const getSocketIO = () => {
  if (!io) {
    throw new Error('Socket.IO not initialized');
  }
  return io;
};

/**
 * Emit events directly via Socket.IO (bypasses Redis pub/sub).
 * Used as fallback when Redis is unavailable, ensuring KDS/clients
 * always receive events even without Redis.
 */
const emitLocal = (channel, data) => {
  if (!io) return false;

  try {
    switch (channel) {
      case 'table:update':
        io.to(`floor:${data.outletId}:${data.floorId}`).emit('table:updated', data);
        io.to(`outlet:${data.outletId}`).emit('table:updated', data);
        break;

      case 'order:update':
        io.to(`outlet:${data.outletId}`).emit('order:updated', data);
        io.to(`captain:${data.outletId}`).emit('order:updated', data);
        io.to(`cashier:${data.outletId}`).emit('order:updated', data);
        break;

      case 'kot:update': {
        const kotNum = data.kot?.kotNumber || data.kot?.id || 'unknown';
        const emittedRooms = [];
        
        logger.info(`[emitLocal] kot:update received - outlet: ${data.outletId}, station: ${data.station}, stationId: ${data.stationId}, type: ${data.type}, kotNumber: ${kotNum}`);
        
        io.to(`kitchen:${data.outletId}`).emit('kot:updated', data);
        emittedRooms.push(`kitchen:${data.outletId}`);
        
        if (data.station) {
          io.to(`station:${data.outletId}:${data.station}`).emit('kot:updated', data);
          emittedRooms.push(`station:${data.outletId}:${data.station}`);
          if (data.station === 'bar' || data.station.includes('bar')) {
            io.to(`bar:${data.outletId}`).emit('kot:updated', data);
            emittedRooms.push(`bar:${data.outletId}`);
          }
        }
        if (data.stationId) {
          io.to(`station_id:${data.outletId}:${data.stationId}`).emit('kot:updated', data);
          emittedRooms.push(`station_id:${data.outletId}:${data.stationId}`);
        }
        io.to(`captain:${data.outletId}`).emit('kot:updated', data);
        io.to(`cashier:${data.outletId}`).emit('kot:updated', data);
        emittedRooms.push(`captain:${data.outletId}`, `cashier:${data.outletId}`);
        
        if (data.type === 'kot:item_ready' || data.type === 'kot:ready') {
          io.to(`captain:${data.outletId}`).emit('item:ready', data);
        }
        
        logger.info(`[emitLocal] KOT ${kotNum} emitted to rooms: ${emittedRooms.join(', ')}`);
        break;
      }

      case 'bill:status':
        io.to(`captain:${data.outletId}`).emit('bill:status', data);
        io.to(`cashier:${data.outletId}`).emit('bill:status', data);
        io.to(`outlet:${data.outletId}`).emit('bill:status', data);
        break;

      case 'payment:update':
        io.to(`cashier:${data.outletId}`).emit('payment:updated', data);
        io.to(`outlet:${data.outletId}`).emit('payment:updated', data);
        break;

      case 'notification':
        io.to(`outlet:${data.outletId}`).emit('notification', data);
        break;

      case 'print:new_job':
        io.to(`outlet:${data.outletId}`).emit('print:new_job', data);
        break;

      default:
        logger.warn(`emitLocal: unhandled channel '${channel}'`);
        return false;
    }
    return true;
  } catch (error) {
    logger.error(`emitLocal failed for channel '${channel}':`, error.message);
    return false;
  }
};

// Emit helpers (use publishMessage for local fallback when Redis is unavailable)
const emit = {
  toOutlet(outletId, event, data) {
    publishMessage(event.split(':')[0] + ':update', { outletId, ...data });
  },

  toFloor(outletId, floorId, event, data) {
    publishMessage('table:update', { outletId, floorId, ...data });
  },

  toKitchen(outletId, event, data) {
    publishMessage('kot:update', { outletId, ...data });
  },

  notification(outletId, message, type = 'info') {
    publishMessage('notification', { outletId, message, type, timestamp: new Date() });
  },
};

module.exports = {
  initializeSocket,
  getSocketIO,
  emitLocal,
  emit,
};
